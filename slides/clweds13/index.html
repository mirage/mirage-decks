<section data-markdown class="title center">
  <script type="text/template">
    # MirageOS: Modular Systems Programming<br />

    Anil Madhavapeddy, University of Cambridge
    <br />
    Computer Laboratory Wednesday Seminar Series, Dec 2013
    <br />

    <div style="font-size: 24pt">
      __Homepage__: [http://openmirage.org](http://openmirage.org)
      <br />
      __Slides__: [http://decks.openmirage.org/clweds13/](http://decks.openmirage.org/facebook13/#/)
      <br />
      __Screencast__: [http://youtu.be/2Mx8Bd5JYyo](http://www.youtube.com/watch?v=2Mx8Bd5JYyo)
    </div>
    <br />
    <small>Press &lt;esc&gt; to view the slide index, and the &lt;arrow&gt; keys to navigate.</small>
 </script>
</section>

<section>
  <section data-markdown>
    <script type="text/template">
    ## Systems Programming Today

    > It’s considered good programming practice to focus
    > on compositionality: build software out of small, well-defined
    > modules that combine to give rise to other modules with different
    > behaviors.
    >
    > **This is simply too difficult to do in distributed systems. Why?**

    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
*-- Marius Eriksen, Principal Engineer, Twitter* *([source](http://monkey.org/~marius/sosp13.html))*

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## From simple servers...

    Traditional systems programming has involved building services in
    one environment.  E.g. Server, client, or embedded.

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
    ## ...To deep-sea diving

    Traditional systems programming has involved building services in
    one environment.  E.g. Server, client, or embedded.

    <br />
    A modern programmer has to deal with incredible diversity of targets:

    - **Cloud services** with unpredictable traffic spikes and failures.
    - **Smartphone programming** on ARM/x86 with power budgets.
    - **JavaScript** user interfaces with asynchronous web clients.
    - **Internet of Things** devices that have little ARM M0 processors.
    - **Kernel modules** to extend operating system functionality.

    <br />
    Quite often, one problem straddles multiple targets, with little
    opportunity for code re-use.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Systems Programming Today

    This is particularly true in a modern operating system.  APIs such
    as POSIX are difficult to evolve for changing needs.

    E.g. **Network intrusion detection** thats inspects packets bypasses kernel.

    fds.fd = open("/dev/netmap", O_RDWR);
    strcpy(nmr.nm_name, "ix0");
    ioctl(fds.fd, NIOCREG, &nmr);
    p = mmap(0, nmr.memsize, fds.fd);
    nifp = NETMAP_IF(p, nmr.offset);
    fds.events = POLLOUT;
    for (;;) {
        poll(fds, 1, -1);
        for (r = 0; r < nmr.num_queues; r++) {
        ring = NETMAP_TXRING(nifp, r);
        while (ring->avail-- > 0) {
            i = ring->cur;
            buf = NETMAP_BUF(ring, ring->slot[i].buf_index);
            ... store the payload into buf ...
            ring->slot[i].len = ...
            ring->cur = NETMAP_NEXT(ring, i);
        }
    }
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Systems Programming Today

    > It’s considered good programming practice to focus
    > on compositionality: build software out of small, well-defined
    > modules that combine to give rise to other modules with different
    > behaviors.
    >
    > This is simply too difficult to do in distributed systems. Why?

    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
*-- Marius Eriksen, Principal Engineer, Twitter* *([source](http://monkey.org/~marius/sosp13.html))*

    <div class="fragment">
    <br />
    **Isn't this just Java? Write once, run anywhere?**
    </div>

    <div class="fragment">
    <ul>
    <li>Java has a heavyweight runtime model and is now addicted to the JIT.
    <li>Difficult to squeeze into embedded targets due to memory footprint.
    <li>Heavy emphasis on inheritance and less on modular composition.
    </ul>
    </div>

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Possible Solution!

    These slides are written in a new operating system called [MirageOS](http://openmirage.org):

    - Hosted on a <b>~1MB Xen microkernel written in statically
    type-safe OCaml</b>, including the device drivers, TCP and HTTP stack.

    - The application code was just a <b>couple of source files</b>, with
    all the hard work done in the MirageOS toolchain.

    - The kernel is <b>running on the public cloud</b> on Amazon EC2, with
    the binaries small enough to be tracked in Git.

    - The same code can run under Unix or as a FreeBSD kernel module.

    <br />Let's focus on cloud programming, and come back to the other uses later.
    </script>
  </section>
</section>

<section>

  <section data-markdown>
    <script type="text/template">
    ## Xen: the Challenge

    - **XenServer** is a complete distribution of the Xen hypervisor.
    - Now open-source and deployed on millions of hosts worldwide.
    - Huge cloud providers such as [Rackspace](http://rackspace.com) use it.

    <div class="fragment">
    <br />
    <blockquote>While Xen is used to manage millions of our customer's virtual machines,
    how we do we manage and secure Xen itself?
    <br /><br />
    We need to build a "**distributed system in a box**" that breaks up the
    monolithic systems software into components that run
    with minimal privilege, yet are still easy to develop, deploy and debug.
    </blockquote><br />
    <p align="right">- David J. Scott, Principal Architect, XenServer</p>
    </div>
   </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Xen: the Challenge

    - **XenServer** is a complete distribution of the Xen hypervisor.
    - Now open-source and deployed on millions of hosts worldwide.
    - Huge cloud providers such as [Rackspace](http://rackspace.com) use it.

    <br />
    The XenServer software stack is around ~200k lines of OCaml code.

    - a distributed database
    - APIs for XML-RPC
    - fault tolerance algorithms
    - datacentre management UI
    - storage and network configuration plugins

    <br />
    *(source: [ICFP 2010 experience report](http://anil.recoil.org/papers/2010-icfp-xen.pdf))*
    </div>
   </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## The Cloud Threat Model

      <img src="threat-model-dom0.png" />
      <div class="fragment">
      <p class="bubble  right"
         style="top: -300pt; left: 180pt; width: 7em">
         Control stack is monolithic and has complete privileges.
        </p>
      </div>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## The Cloud Threat Model

      <img src="threat-model.png" />

      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm"
             src="green-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <p class="bubble  right"
           style="top: -440pt; left: -5pt; width: 11em">
          Type-safety in the application layer defeats several external threats.
        </p>
     </div>

      <div class="fragment">
        <img class="arrow"
             style="top: -482pt; left: 307pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="green-arrow.png" />

        <p class="bubble "
           style="top: -730pt; left: 370pt; width: 12em">
          Type-safety in the kernel will make all external I/O safe, but at what
          cost?
        </p>
      </div>

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Current Virtual Appliances

      <img src="vapps-current.png" />

      Compiler has to stop at userspace.

      Every level has a different API, calling convention, and privilege requirements.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-1.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-2.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-3.png" />
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Target the hypervisor

      <img src="key-insight.png" />
      <p class="fragment bubble "
         style="top: -320pt; left: 190pt; width: 14.5em">
        UNIX processes get mapped onto many small, independent, Virtual Machines forming a distributed system.
      </p>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Key Design Insights

      <img src="key-insight.png" />

      <div class="fragment">
      <p class="bubble"
         style="top: -300pt; left: 220pt; width: 15em">
        The hypervisor gifts us a stable hardware interface. Cures the curse
        of research operating systems!
      </p>
      </div>
      <div class="fragment">
      <p class="bubble left"
         style="top: -260pt; left: 380pt; width: 9.5em">
        Protocol-level compatibility between special-purpose
        appliances is enough.
      </p>
      </div>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Contributions

      + The **unikernel approach** to building single-purpose appliances
        + Library OS + high level programming interface.
        + Single-address space layout.

      <br />

      + Evaluation of these techniques using **functional programming**
        (OCaml)
        + Benefits of type-safety need not damage performance.
        + Static typing + modules = high level manipulation of OS constructs.
        + Modularity, not object-orientation, at scale.

      <br />

      + Precise **dependency tracking** of all the inputs to deployed binaries.

    </script>
  </section>
</section>


<section>
  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    <br />
    While this traditionally means a monolithic OS such as Linux or Windows,
    it can also describe a **library operating system**.

    - Every OS service exposed as a library with few ambient services.
    - Application links directly with the drivers to boot (a *"unikernel"*)
    - A natural fit to the ML module system.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

    let rec qsort = function
        | [] -> []
        | pivot :: rest ->
            let is_less x = x < pivot in
            let left, right = List.partition is_less rest in
            qsort left @ [pivot] @ qsort right

    **Why?**
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

    let rec qsort = function
        | [] -> []
        | pivot :: rest ->
            let is_less x = x < pivot in
            let left, right = List.partition is_less rest in
            qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - to run as native code
    - a garbage collector
    - a console log to record output
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

    let rec qsort = function
        | [] -> []
        | pivot :: rest ->
            let is_less x = x < pivot in
            let left, right = List.partition is_less rest in
            qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

   <section data-markdown>
        <script type="text/template">
          ## Kernel Memory Management

          <img src="memory-model.png" />


          <p class="fragment bubble"
             style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
            Compiled native source code and runtime statically linked and boots
            directly into Xen.
          </p>

          <p class="fragment bubble  right"
             style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
            IO memory is mapped into a reserved area and can be distinguished.
          </p>

          <p class="fragment bubble  left"
             style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
            OCaml heap is contiguous, with simpler write barriers as a result.
          </p>

        </script>
      </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

    let rec qsort = function
        | [] -> []
        | pivot :: rest ->
            let is_less x = x < pivot in
            let left, right = List.partition is_less rest in
            qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

    let rec qsort = function
        | [] -> []
        | pivot :: rest ->
            let is_less x = x < pivot in
            let left, right = List.partition is_less rest in
            qsort left @ [pivot] @ qsort right

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - **implement language-level concurrency via monads**
    - **build device drivers via modular blocks**
    </script>
  </section>
</section>


<section>
  <section data-markdown>
    <script type="text/template">
    ## Monads

    module type MONAD = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

* A monad is a box that contains an abstract value.
* Put values in the box with `return`
* Transform them into other values with `bind`

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## The Option Monad

    Let's implement a monad that expresses optional values, starting in the OCaml interactive toplevel.

    # Some "apple" ;;
    - : string option = Some "apple"

    # None ;;
    - : 'a option = None

    # let return x = Some x ;;
    val return : 'a -> 'a option = <fun>

    # let maybe u f =
        match u with
        | Some c -> f c
        | None   -> None ;;
    val maybe : 'a option -> ('a -> 'b option) -> 'b option = <fun>

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

    module OptionMonad =
      struct
        type α t = α option

        let bind u f =
            match f with
            | Some x -> f x
            | None   -> None

        let return u = Some u
      end

The toplevel will report the following type:

    module OptionMonad = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

    module OptionMonad =
      struct
        type α t = α option

        let bind u f =
            match f with
            | Some x -> f x
            | None   -> None

        let return u = Some u
      end

    - The value in the box may or may not exist, so is `type α option`
    - `return` places a concrete value in the box.
    - `bind` applies a function to it if it exists, and does nothing otherwise.

    - Notice that the `f x` application in `bind` is *not* wrapped in a `Some`.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: examples

    Some simple uses of these definitions:

    open OptionMonad ;;
    bind
      (return 1)
      (fun c -> return (c+1)) ;;
    - : int option = Some 2

    bind
      None
      (fun c -> return (c+1)) ;;
    - : int option = None

    Binds can be chained to link the results.

    bind (
      bind
        (Some 1)
        (fun c -> return (c+1))
      ) (fun c -> return (c+1)) ;;
    - : int option = Some 3

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

    let (>>=) = bind ;;
    val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

    return 1 >>= fun c ->
    return (c+1) >>= fun c ->
    return (c+1) ;;
    - : int option = Some 3

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

    let (>>=) = bind ;;
    val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

    return 1 >>= fun c ->
    return (c+1) >>= fun c ->
    return (c+1) ;;
    - : int option = Some 3

    Or define a `maybe_add` function to be even more succinct.

    let maybe_add c = return c + 1 ;;
    val maybe_add : int -> int option = <fun>

    return 1
    >>= maybe_add
    >>= maybe_add
    - : int option = Some 3

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Monad Laws

    module type MONAD = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

* Monad implementations must satisfy some laws.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: left identity

    module type MONAD = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

    `return` is a left identity for `bind`

    return x >>= f
    f x

    Using the OptionMonad:

    # return 1 >>= maybe_add ;;
    - : int option = Some 2

    # maybe_add 1;;
    - : int option = Some 2

    # return (Some 1) >>= maybe_add

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: right identity

    module type MONAD = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

    `return` is a right identity for `bind`

    m >>= return
    m

    Using the OptionMonad:

    # Some 1 >>= return
    - : int option = Some 1

    # None >>= return
    - : 'a option = None

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: associativity

    module type MONAD = sig
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

    `bind` is associative (in an odd way).

    (u >>= f) >>= g
     u >>= (fun x -> f x) >>= g

    Using the OptionMonad:

    # Some 3 >>= maybe_add >>= maybe_add ;;
    - : int option = Some 5

    # Some 3 >>= (fun x -> maybe_add x >>= maybe_add) ;;
    - : int option = Some 5

    </script>
  </section>
</section>

<section>

  <section data-markdown>
    <script type="text/template">
    ## Cooperative Concurrency

    There are quite a few uses for monads; we'll use this to build a cooperative concurrency model for our OS.

    module Lwt = struct
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t
    end

    The `Lwt` (Light Weight Thread) monad signature above represents a *future computation* that is held in the box.

    Can construct *futures* and compute using them by using `bind` to operate over its eventual value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Constant threads

    open Lwt ;;
    let future_int = return 1 ;;
    val future_int : int Lwt.t = <abstr>

    Build a constant thread by using `return`.

    let future_fruit = return "apple" ;;
    val future_fruit : string Lwt.t = <abstr>

    let future_lang = return `OCaml ;;
    val future_lang : [> `OCaml] Lwt.t = <abstr>

    Threads are first-class OCaml values and parametric polymorphism lets you
    distinguish different types of threads.

    No system threads are involved at all; this is sequential code.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

    module OS = struct
        val sleep : float -> unit Lwt.t
        val run : 'a Lwt.t -> 'a
    end

    The monad needs to be *executed* to retrieve the future contents.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

    module OS = struct
        val sleep : float -> unit Lwt.t
        val run : 'a Lwt.t -> 'a
    end

    The monad needs to be *executed* to retrieve the future contents.

    let t =
      OS.sleep 1.0 >>= fun () ->
      print_endline ">> start";
      OS.sleep 2.0 >>= fun () ->
      print_endline ">> woken up";
      return () ;;
    val t : unit Lwt.t = <abstr>

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

    module OS = struct
        val sleep : float -> unit Lwt.t
        val run : 'a Lwt.t -> 'a
    end

    The monad needs to be *executed* to retrieve the future contents.

    let t =
      OS.sleep 1.0 >>= fun () ->
      print_endline ">> start";
      OS.sleep 2.0 >>= fun () ->
      print_endline ">> woken up";
      return () ;;
    val t : unit Lwt.t = <abstr>

    OS.run t ;;
    >> start
    >> woken up

    The `run` function takes a future and unpacks the real value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Joinad: not quite a monad

    module Lwt = struct
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t

        val join : unit t list -> unit t
        val choose : α t list -> α t
    end

    We extend the `MONAD` signature with:

    - `join` to wait for a list of threads to terminate.
    - `choose` to return as soon as one thread of a list completes.
    - `join` is also defined as the `<&>` operator, and `choose` as `<?>`.

    <br/>
    *(see [tomasp.net](http://tomasp.net) and [tryjoinads.org](http://tryjoinads.org) for more background)*

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Example: flip a coin

    module Lwt = struct
        type α t
        val bind : α t -> (α -> β t) -> β t
        val return :  α -> α t

        val join : unit t list -> unit t
        val choose : α t list -> α t
    end

    Using `choose` to pick the first thread in a coin flip:

    let flip_a_coin () =
      let heads =
        OS.sleep 1.0 >>= fun () ->
        return (OS.log "Heads") in
      let tails =
        OS.sleep 2.0 >>= fun () ->
        return (OS.log "Tails") in
      heads <&> tails

    </script>
  </section>



  <section data-markdown>
    <script type="text/template">
    ## Representation of a thread

    type 'a t = {
        | Return of 'a
        | Fail of exn
        | Sleep of 'a sleeper
    }
    and sleeper = {
        waiters : 'a waiter_set;
        <...etc>
    }

    Thread has three main states:

    - It has **completed** and contains a concrete `Return` value.
    - It has **failed** and contains a concrete `Fail` exception.
    - It is **blocked** and waiting on another thread.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

    type 'a t  (* thread *)
    type 'a u  (* wakener *)
    val wait : unit -> 'a t * 'a u
    val wakeup : 'a u -> 'a -> unit

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

    type 'a t  (* thread *)
    type 'a u  (* wakener *)
    val wait : unit -> 'a t * 'a u
    val wakeup : 'a u -> 'a -> unit

    Tasks are a pair: a thread that sleeps until it is fulfilled via its wakener by calling `wakeup` on it.

    let t1 =
      t >>= fun x ->
      print_endline x;
      return ()
    and t2 =
      OS.sleep 2.0 >>= fun () ->
      wakeup u "x";
      return ()

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: building a timer

    Wakeners are enough to build our `OS.sleep` function:

    - Call `sleep` with `t` seconds as an argument.
    - Create a thread `t` and a wakener `u`.
    - Insert `u` into a priority queue of timeouts, ordered by duration.
    - The application sleeps on `t` until `u` is invoked by the scheduler.

    <br />
    The priority queue is a standard data structure ordered by duration.

    module Sleep_queue =
        Lwt_pqueue.Make(struct
            type t = sleeper
            let compare { time = t1 } { time = t2 } = compare t1 t2
        end)
    end

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Unix

    The `OS.main` function runs until all threads are blocked,
    and then drops into the `select` function to wait for the next timeout.

    run main thread (threads register timeouts)
    if result is Blocked then
        T = head of priority queue
        select() for T seconds
        wakeup timeouts
    repeat until main thread result is Done or Fail

     - This lets our sequential code be fully concurrent, without preemptive system threads.
     - Number of threads limited only by OCaml heap size.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    **But how does this translate to Xen?**

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

    module OS = struct
        val sleep : float -> unit Lwt.t
        val run : 'a Lwt.t -> 'a
    end
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

    Our Xen VM can use this abstraction for all its I/O and timing.

    **Question: What is the major downside of this approach?**
    </script>
  </section>


</section>

<section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.

      ```
let main () =
    lwt zones = read key "zones" "zone.db" in
    Net.Manager.bind (fun mgr dev ->
        let src = `any_addr, 53 in
        Dns.Server.listen dev src zones
    )
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.

      ```
      # ip-use-dhcp: true
      ip-address: 10.0.0.2
      ip-netmask: 255.255.255.0
      ip-gateway: 10.0.0.1
      fs-static: ../storage
      main-ip: Ping.main
      depends: mirage-net
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.

      ```
$ opam install mirage-unix mirage-www
$ mirari run --unix
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!

      ```
$ opam install mirage-xen mirage-www
$ mirari run --xen
$ xl create -c mirage-www.conf
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!
      - The magic happens via the OCaml module system.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules1.png" />

    </script>
  </section>


   <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules2.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules3.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Building these modules

      OPAM includes a SAT-solver to pick modules for a given hardware target *(can include Xen vs Linux dom0+Xen vs kFreeBSD)*

      Libraries are lightweight and independent (on GitHub):

      - **[mirage/ocaml-xenstore](https://github.com/mirage/ocaml-xenstore)** - abstract, Unix/Xen interface.
      - **[mirage/shared-memory-ring](https://github.com/mirage/shared-memory-ring)** - shared memory protocol for Xen drivers.
      - **[mirage/ocaml-xen-block-driver](https://github.com/mirage/ocaml-xen-block-driver)** - Unix/Xen Blkfront/Blkback.
      - **[mirage/ocaml-vchan](https://github.com/mirage/ocaml-vchan)** - Unix/Xen Vchan shared memory transport.
      - **[mirage/mirage-platform](https://github.com/mirage/mirage-platform)** - UNIX/Xen/NS3 versions of timer, shared memory and event channels.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Example: Blkfront

      ```
module type BLOCK_DEVICE = sig
  type t
  type 'a io
  type page_aligned_buffer
  type error =
  | Unknown of string

  type info = {
    read_write: bool;    (** True if we can write, false if read/only *)
    sector_size: int;    (** Octets per sector *)
    size_sectors: int64; (** Total sectors per device *)
  }

  val get_info: t -> info io
  val read: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
  val write: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
end

```

    </script>
  </section>

   <section data-markdown>
    <script type="text/template">
      ## MirageOS Screencast

<iframe width="600" height="400" src="//www.youtube.com/embed/2Mx8Bd5JYyo" frameborder="0" allowfullscreen></iframe>

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Progressive Specialisation

      <img style="padding: 1ex 1em; max-width: 90%" src="specialisation.png" />

    </script>

  </section>


</section>

<section>
  <section data-markdown>
    <script type="text/template">
      ## Microbenchmarks!

      Unikernel appliances are:

      + Smaller, both in kLoC & image size
      + Boot faster, _at packet round-trip time timescales_
      + High performance
      + Type-safe

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Appliance Image Size

      <table style="border-bottom: 1px black solid">
        <thead style="font-weight: bold">
          <td style="border-bottom: 1px black solid; width: 15em">Appliance</td>
          <td style="border-bottom: 1px black solid">Standard Build</td>
          <td style="border-bottom: 1px black solid">Dead Code Elimination</td>
        </thead>
        <tbody>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>DNS</td><td>0.449 MB</td><td>0.184 MB</td>
          </tr>
          <tr>
            <td>Web Server</td><td>0.674 MB</td><td>0.172 MB</td>
          </tr>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>Openflow learning switch</td><td>0.393 MB</td><td>0.164 MB</td>
          </tr>
          <tr>
            <td>Openflow controller</td><td>0.392 MB</td><td>0.168 MB</td>
          </tr>
        </tbody>
      </table>

      <br />
      All configuration and data compiled into the image by the toolchain.

      Live migration is easy and fun :-)
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Boot Time

      <img src="boot-time.png" />

      _Unikernels are compact enough to boot and respond to network traffic in
      real-time._
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## How Large is Large?

      <img src="kloc.png">
      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Event Driven Co-Threads

        <img style="padding-top:1ex" src="cothreads.png" />

        _Garbage collected heap management is more efficient in a single
        address-space environment. Thread latency can be reduced by eliminating
        multiple levels of scheduling._

      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Thread Scaling <small>single instance</small>

        <img src="thread-scaling.png" />

        _Threads are heap allocated values, so benefit from the faster garbage
        collection cycle in the Mirage Xen version, and the scheduler can be
        overridden by application-specific needs._

      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Block Storage

        <img style="max-width: 78%;" src="block-storage.png" />

        _Additionally, reading __from__ a Mirage NAS-like storage VM achieves
        942MiB/s buffered, and 1.8GiB/s unbuffered._

        </script>
      </section>

    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ## Techniques

          Several implementation techniques give rise to these benefits:

          + Simplified memory management
          + Zero-copy IO buffer management
          + Hypervisor security extension for _VM sealing_ (`W^X`)

        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ## Kernel Memory Management

          <img src="memory-model.png" />


          <p class="fragment bubble"
             style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
            Compiled native source code and runtime statically linked and boots
            directly into Xen.
          </p>

          <p class="fragment bubble  right"
             style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
            IO memory is mapped into a reserved area and can be distinguished.
          </p>

          <p class="fragment bubble  left"
             style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
            OCaml heap is contiguous, with simpler write barriers as a result.
          </p>

        </script>
      </section>


      <section data-markdown>
        <script type="text/template">
          ## Buffer Management <small>Zero-Copy IO</small>

          <img src="zero-copy-io.png">
          </script>
        </section>


        <section data-markdown>
          <script type="text/template">
            ## Optional VM Sealing

            + **Single address-space** and *no dynamic loading*
              + `W^X` address space
              + Address offsets are randomized at compile-time

            <br />

            + Dropping page table privileges:
              + Added freeze hypercall called just before app starts
              + Subsequent page table updates are rejected by Xen
              + Exception for I/O mappings if they are non-exec and do not modify
                any existing mappings

            <br />

            + Very easy in unikernels due to focus on __compile-time specialisation__
            instead of _run-time complexity_

          </script>
        </section>
      </section>

      <section>
        <section data-markdown>
          <script type="text/template">
            ## Macrobenchmarks

            We have implemented several larger appliances.

            We discuss _deens_, our DNS server in detail here.

            We also have:

            + a simple webserver,
            + an OpenFlow Switch, and
            + an OpenFlow Controller.

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Code

            <pre style="box-shadow: none">
              <code style="font-size:32px; line-height:1.1">

            let main () =
              lwt zones = read key "zones" "zone.db" in
              Net.Manager.bind (fun mgr dev ->
                let src = `any_addr, 53 in
                Dns.Server.listen dev src zones
              )

              </code>
            </pre>

            <p class="fragment bubble "
               style="top: -360pt; left:70pt; width:10em">
              Cooperative threads as functions
            </p>

            <p class="fragment bubble "
               style="top: -420pt; left:400pt; width:10em">
              Statically evaluated configuration
            </p>

            <p class="fragment bubble  top"
               style="top: -310pt; left:300pt; width:10em">
              Functional callbacks
            </p>

            <p class="fragment bubble  top"
               style="top:-310pt; left:0pt; width: 10em">
              Libraries directly link to network stack
            </p>

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>baseline</small>

            <img style="max-width: 85%" src="dns-baseline.png" />

            _Baseline figures, running __Bind__ (standard) and __NSD__ (high
            performance). NSD achieves around 70 kreqs/s._

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>mirage</small>

            <img style="max-width: 85%" src="dns-deens.png" />

            _Comparing against __Mirage__ appliance, with and without simple
            memoisation. This __algorithmic__ optimisation added just 6 lines of code._
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>C/miniOS</small>

            <img style="max-width: 85%" src="dns-all.png" />

            _A rudimentary C-based appliance linking NSD directly against
            MiniOS. Poor user-space library performance
            vastly outweighs language effects._
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## Scaling <small>via Parallel Instances</small>

            <img  src="scaling-instances.png" />

            _Request throughput for serving a simple static page using  Apache on Linux
            vs. a Mirage appliance. Rather than pay the cost of interlocking for
            thread-level parallelism, we scale by running many instances of the
            Mirage appliance._

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## Openflow Controller

            <img src="openflow-controller.png">

              _OpenFlow controller is competitive with NOX (C++), but much higher
              level. Applications can link directly against the switch to route their
              data._

            </script>
          </section>
        </section>
<section>
  <section data-markdown>
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

<br />

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1a.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1b.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1c.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1d.png" height="710" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

<br />

      + Unikernels are small and can be tracked in GitHub!
        + For Mirage website, source is committed to **[mirage/mirage-www](https://github.com/mirage/mirage-www)**
        + Pull requests to source are built by **[Travis-CI](https://travis-ci.org)**
        + Resulting binary committed to **[mirage/mirage-www-deployment](https://github.com/mirage/mirage-www-deployment)**
        + Cloud toolstack spawns VMs based on pushes there.

    </script>
  </section>
</section>


  <section>
   <section data-markdown>
     <script type="text/template">
      ## Experiences

      + __OCaml is the baseline language for all new code__
        + Our C runtime is small, and getting smaller.
        + Is fully event-driven and non-preemptive.
        + Safe modularity at scale is incredible.
      + __Rewriting protocols wasn&rsquo;t that hard__
        + An extremely useful learning experience.
        + Clean slate often highlights research opportunities.
        + Pickup by industry has been vital.
      + __Unikernels fit perfectly on the cloud__
        + Internet protocol building blocks.
        + Seamless interop with legacy code through VMs.
      </script>
    </section>

<!--
     <section data-markdown>
      <script type="text/template">
       ## Pure OCaml Code <small>[github.com/mirage](http://github.com/mirage)</small>

       + **Device drivers**
          + xenstore, ring, grant tables, boot loader
          + netfront, blkfront, vchan
       + **Networking/Communication**
          + IP/TCP/UDP/DHCP/DNS(SEC) (v4)
          + HTTP, SSH, OpenFlow (controller/switch)
          + VNC, TTY
       + **Storage**
          + NFS, FAT32, 9P, Git
          + [arakoon.org](http://arakoon.org): multi-Paxos distributed k/v store
      </script>
    </section>
-->
    <section data-markdown>
    <script type="text/template">
      ## MirageOS 1.0 - December 2013

      - It's not just the source code: __tools matter__ too.
          - Release efforts are focussed around usability of build/deployment.
          - OPAM 1.1 package manager that works via GitHub: **<https://opam.ocaml.org>**
          - over 50 OCaml libraries released (TCP/IP, Xen drivers, protocols)

      <br />

      - OPAM now has **over 1800 packages** (559 unique)
          - lots of enthusiasm from the OCaml community!
          - growing corpus of re-usable code
          - a single place to discover functionality
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## OPAM Package Growth

      <img src="packages.png" />
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## To the Edge of the Cloud

      The library OS approach is far more general than just cloud programming.

      - **ARMv6/Raspberry Pi** - needs device drivers for framebuffer/USB
      - **kernel/FreeBSD** - OS environment is a kernel module
      - **JavaScript/browser** - map WebSockets/HTML5 Storage
      - **ARMv8/Xen** - emerging support for new ARM hypervisors
      - **VMWare/KVM/LXC** - more hypervisor boot libraries
      - **Unix/Capsicum/CHERI** - secure capability hardware

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Use Cases that Drive Us

      - __Personal Hosting__ ([User Centric Networking](http://usercentricnetworking.eu))
        - Our homepages moving onto little self-contained kernels.
        - Self-scaling servers that spawn VMs in response to demand.
        - ARM Raspberry Pi protocol servers.
        - Security less of a problem due to dependency tracking.

      <br />

      - __Network as a Service__
        - Data centre applications customize their network needs.
        - Operations over big data can specialize to workloads.
        - Exploring the hardware/software divide.


    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## But lots of polishing to do!

      - __Low latency toolstacks__
        - Nothing stops Xen being as easy as containers.
        - Focus has been on large VMs, but being optimized.
        - Streaming kernels via HTTP-RPC now works.
      - __Configuration Language__
        - Very raw in 1.0, but usecases will drive it.
        - All the policy has been pushed out here.
      - __More seamless interoperability__
        - Combine with other languages (**[ocamllabs/ocaml-ctypes](https://github.com/ocamllabs/ocaml-ctypes)**)
        - More boot libraries (KVM, VirtualBox, Docker, rPi, Xen/ARM).
        - Scheduling in such extremely distributed systems.

    </script>
  </section>

  <section data-markdown>
      <script type="text/template">
      <img width="220" src="rwo.jpg" style="margin-left: 680px; margin-top: 150px; position: fixed" />
      ## MirageOS Online

      + Website, <http://www.openmirage.org>
      + Code, <http://github.com/mirage>
      + O'Reilly OCaml book, <http://realworldocaml.org>

      + All development open and on GitHub:
         + **<https://github.com/mirage>**
         + **<https://github.com/xapi-project>**
         + **<https://github.com/xenserver>**

      On behalf the core team of Thomas Gazagnaire, David Scott, Richard Mortier and Jon Ludlam, with extensive contributions from Haris Rotsos, Balraj Singh, Amir Chaudhry, Leo White, Jeremy Yallop, David Sheets and Vincent Bernardoff.  Professorial prodding from Jon Crowcroft and Steven Hand.
      </script>
   </section>

</section>
