<section data-markdown="" class="title center">
  <script type="text/template">
    # Modular Operating System Construction <br />

    Anil Madhavapeddy, University of Cambridge
    <br />
    ACS Advanced Functional Programming
    <br />

    <div style="font-size: 24pt">
      __Homepage__: [http://openmirage.org](http://openmirage.org)
      <br />
      __Slides__: [http://decks.openmirage.org/cam13/](http://decks.openmirage.org/facebook13/#/)
      <br />
      __Screencast__: [http://youtu.be/2Mx8Bd5JYyo](http://www.youtube.com/watch?v=2Mx8Bd5JYyo)
    </div>
    <br />
    <small>Press &lt;esc&gt; to view the slide index, and the &lt;arrow&gt; keys to navigate.</small>
  </script>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## These Slides Are...

      - Hosted on a <b>small Xen microkernel written in statically
      type-safe OCaml</b>, including the device drivers and TCP stack.

      - The application code was just a <b>couple of source files</b>, with
      all the hard work done in the MirageOS toolchain.

      - The kernel is <b>running on the public cloud</b> on Amazon EC2, with
      the binaries tracked in GitHub.

      <br />

      I'll explain how this all fits together works during this talk!

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## OS Virtualization (Xen)

      <img src="threat-model.png" />

      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm;"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg);"
             src="red-arrow.png" />

        <p class="bubble left"
           style="top: -344pt; left: 600pt; width: 4em" >
          Internet<br />
          SAN/NAS<br />
          Tenants<br />
          SDN
        </p>
      </div>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## The Cloud Threat Model

      <img src="threat-model.png" />

      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm"
             src="green-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <p class="bubble  right"
           style="top: -440pt; left: -5pt; width: 11em">
          Type-safety in the application layer defeats several external threats.
        </p>
      </div>

      <div class="fragment">
        <img class="arrow"
             style="top: -482pt; left: 307pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="green-arrow.png" />

        <p class="bubble "
           style="top: -730pt; left: 370pt; width: 12em">
          Type-safety in the kernel will make all external I/O safe, but at what
          cost?
        </p>
      </div>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Target the hypervisor

      <img src="key-insight.png" />
      <p class="fragment bubble "
         style="top: -270pt; left: 190pt; width: 15.5em">
        Virtual machines are UNIX processes &ldquo;done right&rdquo; on the
        cloud.
      </p>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Key Design Insights

      <img src="key-insight.png" />

      <p class="bubble"
         style="top: -330pt; left: 220pt; width: 15em">
        The hypervisor gifts us a stable hardware interface. Cures the curse
        of research operating systems!
      </p>

      <p class="bubble left"
         style="top: -320pt; left: 380pt; width: 12em">
        Protocol-level compatibility between special-purpose cloud
        appliances, e.g. a webserver, a database VM.
      </p>

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Current Virtual Appliances

      <img src="vapps-current.png" />

      Compiler has to stop at userspace.

      Every level has a different API, calling convention, and privilege
      requirements.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-1.png" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-2.png" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-3.png" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Contributions

      + The unikernel approach to building single-purpose appliances
        + Library OS + high level programming interface
        + Single-address space layout

      <br />

      + Evaluation of these techniques using a functional programming language
        (OCaml)
        + Benefits of type-safety need not damage performance
        + Static typing + modules = high level manipulation of OS constructs

      <br />

      + Precise source code dependency tracking of *all* the inputs to the
      deployed binary.

    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## What is an Operating System?
      <blockquote><p>
        "An operating system is a collection of software that manages computer
        hardware resources and provides common services for computer programs."
      </p></blockquote>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## What is an Operating System?

      <blockquote><p>
        "An operating system is a collection of software that manages computer
        hardware resources and provides common services for computer programs."
      </p></blockquote>

      <br />
      While this traditionally means a monolithic OS such as Linux or Windows,
      it can also describe a **library operating system**.

      - Every OS service exposed as a library with few ambient services.
      - Application links directly with the drivers to boot (a *"unikernel"*)
      - A natural fit to the ML module system.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## A Minimal Kernel

      A simple OCaml program like this is easy to run without Unix.
      <pre style="box-shadow: none"><code class="ocaml"><![CDATA[let rec qsort = function
    | [] -> []
    | pivot :: rest ->
        let is_less x = x < pivot in
        let left, right = List.partition is_less rest in
        qsort left @ [pivot] @ qsort right]]> </code></pre>

      **Why?**
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## A Minimal Kernel

      A simple OCaml program like this is easy to run without Unix.
      <pre style="box-shadow: none"> <code> <![CDATA[let rec qsort = function
  | [] -> []
  | pivot :: rest ->
      let is_less x = x < pivot in
      let left, right = List.partition is_less rest in
      qsort left @ [pivot] @ qsort right
]]>
      </code></pre>

      **Why?** It runs sequentially, meaning that it only needs:

      - to run as native code
      - a garbage collector
      - a console log to record output
      - no concurrency
      - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## A Minimal Kernel

      A simple OCaml program like this is easy to run without Unix.
      <pre style="box-shadow: none"> <code> <![CDATA[let rec qsort = function
  | [] -> []
  | pivot :: rest ->
    let is_less x = x < pivot in
    let left, right = List.partition is_less rest in
    qsort left @ [pivot] @ qsort right
]]>
      </code></pre>

      **Why?** It runs sequentially, meaning that it only needs:

      - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
      - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
      - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
      - no concurrency
      - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Kernel Memory Management

      <img src="memory-model.png" />

      <p class="fragment bubble"
         style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
        Compiled native source code and runtime statically linked and boots
        directly into Xen.
      </p>

      <p class="fragment bubble  right"
         style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
        IO memory is mapped into a reserved area and can be distinguished.
      </p>

      <p class="fragment bubble  left"
         style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
        OCaml heap is contiguous, with simpler write barriers as a result.
      </p>

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## A Minimal Kernel

      A simple OCaml program like this is easy to run without Unix.
      <pre style="box-shadow: none"> <code> <![CDATA[let rec qsort = function
  | [] -> []
  | pivot :: rest ->
    let is_less x = x < pivot in
    let left, right = List.partition is_less rest in
    qsort left @ [pivot] @ qsort right
]]>
      </code></pre>

      **Why?** It runs sequentially, meaning that it only needs:

      - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
      - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
      - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
      - no concurrency
      - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## A Minimal Kernel

      A simple OCaml program like this is easy to run without Unix.
      <pre style="box-shadow: none"> <code> <![CDATA[let rec qsort = function
  | [] -> []
  | pivot :: rest ->
    let is_less x = x < pivot in
    let left, right = List.partition is_less rest in
    qsort left @ [pivot] @ qsort right
]]>
      </code></pre>

      **Why?** It runs sequentially, meaning that it only needs:

      - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
      - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
      - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
      - **implement language-level concurrency via monads**
      - **build device drivers via modular blocks**
    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Monads
      <pre style="box-shadow: none"><code><![CDATA[module type MONAD = sig
    type α t
    val bind : α t -> (α -> β t) -> β t
    val return :  α -> α t
end]]></code></pre>

      * A monad is a box that contains an abstract value.
      * Put values in the box with `return`
      * Transform them into other values with `bind`
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## The Option Monad

      Let's implement a monad that expresses optional values, starting in the
      OCaml interactive toplevel.
      <pre style="box-shadow: none"> <code> <![CDATA[# Some "apple" ;;
- : string option = Some "apple"

# None ;;
- : 'a option = None

# let return x = Some x ;;
val return : 'a -> 'a option = <fun>

# let maybe u f =
    match u with
    | Some c -> f c
    | None   -> None ;;
  val maybe : 'a option -> ('a -> 'b option) -> 'b option = <fun>
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Option Monad: definition
      <pre style="box-shadow: none"> <code> <![CDATA[module OptionMonad =
  struct
    type α t = α option

    let bind u f =
          match f with
        | Some x -> f x
      | None   -> None

    let return u = Some u
  end
]]>
      </code></pre>

      The toplevel will report the following type:
      <pre style="box-shadow: none"> <code> <![CDATA[module OptionMonad = sig
  type α t
  val bind : α t -> (α -> β t) -> β t
  val return :  α -> α t
end
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Option Monad: definition
      <pre style="box-shadow: none"> <code> <![CDATA[module OptionMonad =
  struct
    type α t = α option

    let bind u f =
      match f with
      | Some x -> f x
      | None   -> None

    let return u = Some u
  end
]]>
      </code></pre>

      - The value in the box may or may not exist, so is `type α option`
      - `return` places a concrete value in the box.
      - `bind` applies a function to it if it exists, and does nothing
        otherwise.

      - Notice that the `f x` application in `bind` is *not* wrapped in a `Some`.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Option Monad: examples

      Some simple uses of these definitions:
      <pre style="box-shadow: none"> <code> <![CDATA[open OptionMonad ;;
bind
  (return 1)
  (fun c -> return (c+1)) ;;
- : int option = Some 2

bind
  None
  (fun c -> return (c+1)) ;;
- : int option = None
]]>
      </code></pre>

      Binds can be chained to link the results.
      <pre style="box-shadow: none"> <code> <![CDATA[bind (
  bind
    (Some 1)
    (fun c -> return (c+1))
  ) (fun c -> return (c+1)) ;;
- : int option = Some 3
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Option Monad: infix operators

      Infix operators make chaining `bind` more natural:
      <pre style="box-shadow: none"> <code> <![CDATA[let (>>=) = bind ;;
val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

return 1 >>= fun c ->
return (c+1) >>= fun c ->
return (c+1) ;;
- : int option = Some 3
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Option Monad: infix operators

      Infix operators make chaining `bind` more natural:
      <pre style="box-shadow: none"> <code> <![CDATA[let (>>=) = bind ;;
val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

return 1 >>= fun c ->
return (c+1) >>= fun c ->
return (c+1) ;;
- : int option = Some 3
]]>
      </code></pre>
      Or define a `maybe_add` function to be even more succinct.
      <pre style="box-shadow: none"> <code> <![CDATA[let maybe_add c = return c + 1 ;;
val maybe_add : int -> int option = <fun>

return 1
>>= maybe_add
>>= maybe_add
- : int option = Some 3
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Monad Laws
      <pre style="box-shadow: none"> <code> <![CDATA[module type MONAD = sig
    type α t
    val bind : α t -> (α -> β t) -> β t
    val return :  α -> α t
end
]]>
      </code></pre>
      * Monad implementations must satisfy some laws.
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Monad Laws: left identity
      <pre style="box-shadow: none"> <code> <![CDATA[module type MONAD = sig
    type α t
    val bind : α t -> (α -> β t) -> β t
    val return :  α -> α t
end
]]>
      </code></pre>

      `return` is a left identity for `bind`
      <pre style="box-shadow: none"> <code> <![CDATA[return x >>= f
f x
]]>
      </code></pre>

      Using the OptionMonad:
      <pre style="box-shadow: none"> <code> <![CDATA[# return 1 >>= maybe_add ;;
- : int option = Some 2

# maybe_add 1;;
- : int option = Some 2

# return (Some 1) >>= maybe_add
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Monad Laws: right identity
      <pre style="box-shadow: none"> <code> <![CDATA[module type MONAD = sig
  type α t
  val bind : α t -> (α -> β t) -> β t
  val return :  α -> α t
end
]]>
      </code></pre>

      `return` is a right identity for `bind`
      <pre style="box-shadow: none"> <code> <![CDATA[m >>= return
m
]]>
      </code></pre>

      Using the OptionMonad:
      <pre style="box-shadow: none"> <code> <![CDATA[# Some 1 >>= return
- : int option = Some 1

# None >>= return
- : 'a option = None
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Monad Laws: associativity
      <pre style="box-shadow: none"> <code> <![CDATA[module type MONAD = sig
  type α t
  val bind : α t -> (α -> β t) -> β t
  val return :  α -> α t
end
]]>
      </code></pre>

      `bind` is associative (in an odd way).
      <pre style="box-shadow: none"> <code> <![CDATA[(u >>= f) >>= g
 u >>= (fun x -> f x) >>= g
]]>
      </code></pre>

      Using the OptionMonad:
      <pre style="box-shadow: none"> <code> <![CDATA[# Some 3 >>= maybe_add >>= maybe_add ;;
- : int option = Some 5

# Some 3 >>= (fun x -> maybe_add x >>= maybe_add) ;;
- : int option = Some 5
]]>
      </code></pre>
    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Cooperative Concurrency

      There are quite a few uses for monads; we'll use this to build a
      cooperative concurrency model for our OS.
      <pre style="box-shadow: none"> <code> <![CDATA[module Lwt = struct
  type α t
  val bind : α t -> (α -> β t) -> β t
   val return :  α -> α t
end
]]>
      </code></pre>

      The `Lwt` (Light Weight Thread) monad signature above represents a *future
      computation* that is held in the box.

      Can construct *futures* and compute using them by using `bind` to operate
      over its eventual value.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Constant threads
      <pre style="box-shadow: none"> <code> <![CDATA[open Lwt ;;
let future_int = return 1 ;;
val future_int : int Lwt.t = <abstr>
]]>
      </code></pre>

      Build a constant thread by using `return`.
      <pre style="box-shadow: none"> <code> <![CDATA[let future_fruit = return "apple" ;;
val future_fruit : string Lwt.t = <abstr>

let future_lang = return `OCaml ;;
val future_lang : [> `OCaml] Lwt.t = <abstr>
]]>
      </code></pre>

      Threads are first-class OCaml values and parametric polymorphism lets you
      distinguish different types of threads.

      No system threads are involved at all; this is sequential code.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Concurrency: executing

      <pre style="box-shadow: none"> <code> <![CDATA[module OS = struct
  val sleep : float -> unit Lwt.t
  val run : 'a Lwt.t -> 'a
end
]]>
      </code></pre>

      The monad needs to be *executed* to retrieve the future contents.
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Concurrency: executing

      <pre style="box-shadow: none"> <code> <![CDATA[module OS = struct
  val sleep : float -> unit Lwt.t
  val run : 'a Lwt.t -> 'a
end
]]>
      </code></pre>

      The monad needs to be *executed* to retrieve the future contents.
      <pre style="box-shadow: none"> <code> <![CDATA[let t =
  OS.sleep 1.0 >>= fun () ->
  print_endline ">> start";
  OS.sleep 2.0 >>= fun () ->
  print_endline ">> woken up";
  return () ;;
val t : unit Lwt.t = <abstr>
]]>
      </code></pre>
    </script>
  </section>


  <section data-markdown="">
    <script type="text/template">
      ## Concurrency: executing
      <pre style="box-shadow: none"> <code> <![CDATA[
module OS = struct
    val sleep : float -> unit Lwt.t
    val run : 'a Lwt.t -> 'a
end
]]>
      </code></pre>

      The monad needs to be *executed* to retrieve the future contents.

      <pre style="box-shadow: none"> <code> <![CDATA[let t =
  OS.sleep 1.0 >>= fun () ->
  print_endline ">> start";
  OS.sleep 2.0 >>= fun () ->
  print_endline ">> woken up";
  return () ;;
val t : unit Lwt.t = <abstr>

OS.run t ;;
>> start
>> woken up
]]>
      </code></pre>

      The `run` function takes a future and unpacks the real value.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Joinad: not quite a monad
      <pre style="box-shadow: none"> <code> <![CDATA[module Lwt = struct
    type α t
    val bind : α t -> (α -> β t) -> β t
    val return :  α -> α t

    val join : unit t list -> unit t
    val choose : α t list -> α t
end
]]>
      </code></pre>

      We extend the `MONAD` signature with:

      - `join` to wait for a list of threads to terminate.
      - `choose` to return as soon as one thread of a list completes.
      - `join` is also defined as the `&lt;&amp;&gt;` operator, and `choose` as `&lt;?&gt;`.

      <br/>
      *(see [tomasp.net](http://tomasp.net) and
      [tryjoinads.org](http://tryjoinads.org) for more background)*

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Example: flip a coin
      <pre style="box-shadow: none"> <code> <![CDATA[module Lwt = struct
    type α t
    val bind : α t -> (α -> β t) -> β t
    val return :  α -> α t

    val join : unit t list -> unit t
    val choose : α t list -> α t
end
]]>
      </code></pre>

      Using `choose` to pick the first thread in a coin flip:
      <pre style="box-shadow: none"> <code> <![CDATA[let flip_a_coin () =
  let heads =
    OS.sleep 1.0 >>= fun () ->
    return (OS.log "Heads") in
  let tails =
    OS.sleep 2.0 >>= fun () ->
    return (OS.log "Tails") in
  heads <&> tails
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Representation of a thread
      <pre style="box-shadow: none"> <code> <![CDATA[type 'a t = {
    | Return of 'a
    | Fail of exn
    | Sleep of 'a sleeper
}
and sleeper = {
    waiters : 'a waiter_set;
    <...etc>
}
]]>
      </code></pre>

      Thread has three main states:

      - It has **completed** and contains a concrete `Return` value.
      - It has **failed** and contains a concrete `Fail` exception.
      - It is **blocked** and waiting on another thread.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners and tasks

      Each thread executes until it needs to wait on a resource. It creates a
      *task* to let it be woken up in the future.
      <pre style="box-shadow: none"> <code> <![CDATA[type 'a t  (* thread *)
type 'a u  (* wakener *)
val wait : unit -> 'a t * 'a u
val wakeup : 'a u -> 'a -> unit
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners and tasks

      Each thread executes until it needs to wait on a resource. It creates a
      *task* to let it be woken up in the future.
      <pre style="box-shadow: none"> <code> <![CDATA[type 'a t  (* thread *)
type 'a u  (* wakener *)
val wait : unit -> 'a t * 'a u
val wakeup : 'a u -> 'a -> unit
]]>
      </code></pre>

      Tasks are a pair: a thread that sleeps until it is fulfilled via its
      wakener by calling `wakeup` on it.
      <pre style="box-shadow: none"> <code> <![CDATA[let t1 =
  t >>= fun x ->
  print_endline x;
  return ()
and t2 =
  OS.sleep 2.0 >>= fun () ->
  wakeup u "x";
  return ()
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners: building a timer

      Wakeners are enough to build our `OS.sleep` function:

      - Call `sleep` with `t` seconds as an argument.
      - Create a thread `t` and a wakener `u`.
      - Insert `u` into a priority queue of timeouts, ordered by duration.
      - The application sleeps on `t` until `u` is invoked by the scheduler.

      <br />
      The priority queue is a standard data structure ordered by duration.
      <pre style="box-shadow: none"> <code> <![CDATA[module Sleep_queue =
    Lwt_pqueue.Make(struct
        type t = sleeper
        let compare { time = t1 } { time = t2 } = compare t1 t2
    end)
end
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners: running in Unix

      The `OS.main` function runs until all threads are blocked, and then drops
      into the `select` function to wait for the next timeout.

      <pre style="box-shadow: none"> <code> <![CDATA[run main thread (threads register timeouts)
if result is Blocked then
    T = head of priority queue
    select() for T seconds
    wakeup timeouts
repeat until main thread result is Done or Fail
]]>
      </code></pre>

      - This lets our sequential code be fully concurrent, without preemptive
        system threads.
      - Number of threads limited only by OCaml heap size.
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners: running in Xen

      Lwt uses the `select` system call in Unix, which blocks the process until
      some IO event (or a timeout) occurs.

      **But how does this translate to Xen?**

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners: running in Xen

      Lwt uses the `select` system call in Unix, which blocks the process until
      some IO event (or a timeout) occurs.

      Xen has an equivalent *VM block instruction* which suspends the whole VM
      until a device interrupt or timeout.

      > **processes in Unix** &lt;=&gt; **Virtual Machines in Xen**
      > **`select` in Unix** &lt;=&gt; **block entire virtual machine in Xen**

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Wakeners: running in Xen

      Lwt uses the `select` system call in Unix, which blocks the process until
      some IO event (or a timeout) occurs.

      Xen has an equivalent *VM block instruction* which suspends the whole VM
      until a device interrupt or timeout.

        > **processes in Unix**  &lt;=&gt; **Virtual Machines in Xen**
        > **`select` in Unix**  &lt;=&gt; **block entire virtual machine in Xen**

      Our Xen VM can use this abstraction for all its I/O and timing.

      **Question: What is the major downside of this approach?**
    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      <pre style="box-shadow: none"> <code> <![CDATA[let main () =
  lwt zones = read key "zones" "zone.db" in
  Net.Manager.bind (fun mgr dev ->
    let src = `any_addr, 53 in
    Dns.Server.listen dev src zones
  )
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.

      <pre style="box-shadow: none"> <code> <![CDATA[# ip-use-dhcp: true
ip-address: 10.0.0.2
ip-netmask: 255.255.255.0
ip-gateway: 10.0.0.1
fs-static: ../storage
main-ip: Ping.main
depends: mirage-net
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      <pre style="box-shadow: none"> <code> <![CDATA[$ opam install mirage-unix mirage-www
$ mirari run --unix
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!
      <pre style="box-shadow: none">
        <code>
<![CDATA[
$ opam install mirage-xen mirage-www
$ mirari run --xen
$ xl create -c mirage-www.conf
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code.
      - Write a configuration file for the compilation.
      - Compile it under UNIX using the OPAM package manager.
      - Once debugged, just recompile the same source code to Xen!
      - The magic happens via the OCaml module system.

    </script>
  </section>


  <section data-markdown="">
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules1.png" />

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules2.png" />

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules3.png" />

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Building these modules

      OPAM includes a SAT-solver to pick modules for a given hardware target
      *(can include Xen vs Linux dom0+Xen vs kFreeBSD)*

      Libraries are lightweight and independent (on GitHub):

      - **[mirage/ocaml-xenstore](https://github.com/mirage/ocaml-xenstore)** --
        abstract, Unix/Xen interface.
      - **[mirage/shared-memory-ring](https://github.com/mirage/shared-memory-ring)**
      - shared memory protocol for Xen drivers.
      - **[mirage/ocaml-xen-block-driver](https://github.com/mirage/ocaml-xen-block-driver)**
        -- Unix/Xen Blkfront/Blkback.
      - **[mirage/ocaml-vchan](https://github.com/mirage/ocaml-vchan)** -
        Unix/Xen Vchan shared memory transport.
      - **[mirage/mirage-platform](https://github.com/mirage/mirage-platform)**
        -- UNIX/Xen/NS3 versions of timer, shared memory and event channels.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Example: Blkfront

      <pre style="box-shadow: none">
        <code>
<![CDATA[
module type BLOCK_DEVICE = sig
  type t
  type 'a io
  type page_aligned_buffer
  type error =
  | Unknown of string

  type info = {
    read_write: bool;    (** True if we can write, false if read/only *)
    sector_size: int;    (** Octets per sector *)
    size_sectors: int64; (** Total sectors per device *)
  }

  val get_info: t -> info io
  val read: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
  val write: t -> int64 -> page_aligned_buffer list ->
     [ `Error of error | `Ok of unit ] io
end
]]>
      </code></pre>
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS Screencast

<!--
<iframe width="600" height="400" src="//www.youtube.com/embed/2Mx8Bd5JYyo" frameborder="0" allowfullscreen></iframe>
-->
    </script>
  </section>
  <section data-markdown="">
    <script type="text/template">
      ## Progressive Specialisation

      <img style="padding: 1ex 1em; max-width: 90%" src="specialisation.png" />

    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Microbenchmarks!

      Unikernel appliances are:

      + Smaller, both in kLoC &amp; image size
      + Boot faster, _at packet round-trip time timescales_
      + High performance
      + Type-safe

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Appliance Image Size

      <table style="border-bottom: 1px black solid">
        <thead style="font-weight: bold">
          <td style="border-bottom: 1px black solid; width: 15em">Appliance</td>
          <td style="border-bottom: 1px black solid">Standard Build</td>
          <td style="border-bottom: 1px black solid">Dead Code Elimination</td>
        </thead>
        <tbody>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>DNS</td><td>0.449 MB</td><td>0.184 MB</td>
          </tr>
          <tr>
            <td>Web Server</td><td>0.674 MB</td><td>0.172 MB</td>
          </tr>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>Openflow learning switch</td><td>0.393 MB</td><td>0.164 MB</td>
          </tr>
          <tr>
            <td>Openflow controller</td><td>0.392 MB</td><td>0.168 MB</td>
          </tr>
        </tbody>
      </table>

      <br />
      All configuration and data compiled into the image by the toolchain.

      Live migration is easy and fun :-)
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Boot Time

      <img src="boot-time.png" />

      _Unikernels are compact enough to boot and respond to network traffic in
      real-time._
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## How Large is Large?

      <img src="kloc.png" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Event Driven Co-Threads

      <img style="padding-top:1ex" src="cothreads.png" />

      _Garbage collected heap management is more efficient in a single
      address-space environment. Thread latency can be reduced by eliminating
      multiple levels of scheduling._

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Thread Scaling <small>single instance</small>

      <img src="thread-scaling.png" />

      _Threads are heap allocated values, so benefit from the faster garbage
      collection cycle in the Mirage Xen version, and the scheduler can be
      overridden by application-specific needs._

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Block Storage

      <img style="max-width: 78%;" src="block-storage.png" />

      _Additionally, reading __from__ a Mirage NAS-like storage VM achieves
      942MiB/s buffered, and 1.8GiB/s unbuffered._

    </script>
  </section>

</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Techniques

      Several implementation techniques give rise to these benefits:

      + Simplified memory management
      + Zero-copy IO buffer management
      + Hypervisor security extension for _VM sealing_ (`W^X`)

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Kernel Memory Management

      <img src="memory-model.png" />

      <p class="fragment bubble"
         style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
        Compiled native source code and runtime statically linked and boots
        directly into Xen.
      </p>

      <p class="fragment bubble  right"
         style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
        IO memory is mapped into a reserved area and can be distinguished.
      </p>

      <p class="fragment bubble  left"
         style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
        OCaml heap is contiguous, with simpler write barriers as a result.
      </p>

    </script>
  </section>


  <section data-markdown="">
    <script type="text/template">
      ## Buffer Management <small>Zero-Copy IO</small>

      <img src="zero-copy-io.png" />
      </script>
    </section>

    <section data-markdown="">
      <script type="text/template">
        ## Optional VM Sealing

        + Single address-space and no dynamic loading
          + `W^X` address space
          + Address offsets are randomized at compile-time

        + Dropping page table privileges:
          + Added freeze hypercall called just before app starts
          + Subsequent page table updates are rejected by Xen
          + Exception for I/O mappings if they are non-exec and do not modify
            any existing mappings

          <br />

        + Very easy in unikernels due to focus on _compile-time specialisation_
          instead of _run-time complexity_

      </script>
    </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Macrobenchmarks

      We have implemented several larger appliances.

      We discuss _deens_, our DNS server in detail here.

      We also have:

      + a simple webserver,
      + an OpenFlow Switch, and
      + an OpenFlow Controller.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## DNS Server Code

      <pre style="box-shadow: none">
        <code style="font-size:32px; line-height:1.1">
<![CDATA[
let main () =
  lwt zones = read key "zones" "zone.db" in
  Net.Manager.bind (fun mgr dev ->
    let src = `any_addr, 53 in
    Dns.Server.listen dev src zones
  )
]]>
      </code></pre>

      <p class="fragment bubble "
         style="top: -360pt; left:70pt; width:10em">
        Cooperative threads as functions
      </p>

      <p class="fragment bubble "
         style="top: -420pt; left:400pt; width:10em">
        Statically evaluated configuration
      </p>

      <p class="fragment bubble  top"
         style="top: -310pt; left:300pt; width:10em">
        Functional callbacks
      </p>

      <p class="fragment bubble  top"
         style="top:-310pt; left:0pt; width: 10em">
        Libraries directly link to network stack
      </p>

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## DNS Server Performance <small>baseline</small>

      <img style="max-width: 85%" src="dns-baseline.png" />

      _Baseline figures, running __Bind__ (standard) and __NSD__ (high
      performance). NSD achieves around 70 kreqs/s._

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## DNS Server Performance <small>mirage</small>

      <img style="max-width: 85%" src="dns-deens.png" />

      _Comparing against __Mirage__ appliance, with and without simple
      memoisation. This __algorithmic__ optimisation added just 6 lines of
      code._
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## DNS Server Performance <small>C/miniOS</small>

      <img style="max-width: 85%" src="dns-all.png" />

      _A rudimentary C-based appliance linking NSD directly against MiniOS. Poor
      user-space library performance vastly outweighs language effects._
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Scaling <small>via Parallel Instances</small>

      <img  src="scaling-instances.png" />

      _Request throughput for serving a simple static page using Apache on Linux
      vs. a Mirage appliance. Rather than pay the cost of interlocking for
      thread-level parallelism, we scale by running many instances of the Mirage
      appliance._

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Openflow Controller

      <img src="openflow-controller.png" />

      _OpenFlow controller is competitive with NOX (C++), but much higher level.
      Applications can link directly against the switch to route their data._

    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

      <br />

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1a.png" height="700" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1b.png" height="700" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1c.png" height="700" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1d.png" height="710" />
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

      <br />

      + Unikernels are small and can be tracked in GitHub!
        + For Mirage website, source is committed to
          **[mirage/mirage-www](https://github.com/mirage/mirage-www)**
        + Pull requests to source are built by
          **[Travis-CI](https://travis-ci.org)**
        + Resulting unikernel committed to
          **[mirage/mirage-www-deployment](https://github.com/mirage/mirage-www-deployment)**
        + Cloud toolstack spawns VMs based on pushes there.

    </script>
  </section>
</section>

<section>
  <section data-markdown="">
    <script type="text/template">
      ## Experiences with OCaml

      + __OCaml is the baseline language for all new code__
        + Our C runtime is small, and getting smaller.
        + Is fully event-driven and non-preemptive.
        + Safe modularity at scale is incredible.
      + __Rewriting protocols wasn&rsquo;t that hard__
        + An extremely useful learning experience.
        + Clean slate often highlights research opportunities.
        + Pickup by industry has been vital.
      + __Unikernels fit perfectly on the cloud__
        + Internet protocol building blocks.
        + Seamless interop with legacy code through VMs.
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Pure OCaml Code <small>[github.com/mirage](http://github.com/mirage)</small>

      + **Device drivers**
        + xenstore, ring, grant tables, boot loader
        + netfront, blkfront, vchan
      + **Networking/Communication**
        + IP/TCP/UDP/DHCP/DNS(SEC) (v4)
        + HTTP, SSH, OpenFlow (controller/switch)
        + VNC, TTY
      + **Storage**
        + NFS, FAT32, 9P, Git
        + [arakoon.org](http://arakoon.org): multi-Paxos distributed k/v store
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## MirageOS 1.0 - December 2013

      - It's not just the source code: __tools matter__ too.
        - Release efforts are focussed around usability of build/deployment.
        - OPAM 1.1 package manager that works via GitHub: **&lt;[https://opam.ocaml.org](https://opam.ocaml.org)&gt;**
        - over 50 OCaml libraries released (TCP/IP, Xen drivers, protocols)
        - Travis continuous test integration.

        <br />

      - O'Reilly **Real World OCaml** released:
        - **&lt;[http://realworldocaml.org](http://realworldocaml.org)&gt;**
      - OPAM now has **over 1800 packages** (530 unique)
        - lots of enthusiasm from the OCaml community!
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## Cool Uses of Mirage So Far

      - __Personal Hosting__ on the cloud
        - Our homepages moving onto little self-contained kernels.
        - Self-scaling servers that spawn VMs in response to demand.
        - ARM Raspberry Pi HTTP servers.
      - __Custom Middlebox Services__
        - Built custom Xen block backends that do wonderful things.
        - Custom DNS servers that do route discovery and network configuration.
      - __More Secure Services__
        - Self-updated VMs that watch GitHub and recompile in seconds.

    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      ## But lots of polishing to do!

      - __Low latency toolstacks__
        - Nothing stops Xen being as easy as containers.
        - Focus has been on large VMs, but being optimized.
        - Streaming kernels via HTTP-RPC now works.
      - __Configuration Language__
        - Very raw in 1.0, but usecases will drive it.
        - All the policy has been pushed out here.
      - __More backend targets integrated__
        - JavaScript and FreeBSD kernel module backends exist out-of-tree.
        - Combine with other languages (**[ocamllabs/ocaml-ctypes](https://github.com/ocamllabs/ocaml-ctypes)**)
        - More boot libraries (KVM, VirtualBox, Docker, rPi, Xen/ARM)
    </script>
  </section>

  <section data-markdown="">
    <script type="text/template">
      <img width="250" src="rwo.jpg"
           style="margin-left: 680px; margin-top: 150px; position: fixed" />
      ## MirageOS Online

      + Website,&lt;[http://www.openmirage.org](http://www.openmirage.org)&gt;
      + Code,&lt;[http://github.com/mirage](http://github.com/mirage)&gt;
      + O'Reilly OCaml book,&lt;[http://realworldocaml.org](http://realworldocaml.org)&gt;

      <br />

      + All development open and on GitHub:
        + **&lt;[https://github.com/mirage](https://github.com/mirage)&gt;**
        + **&lt;[https://github.com/xapi-project](https://github.com/xapi-project)&gt;**
        + **&lt;[https://github.com/xenserver](https://github.com/xenserver)&gt;**
      </script>
   </section>
</section>
