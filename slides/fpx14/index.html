<section data-markdown class="title center">
  <script type="text/template">
    # My Other Internet is a ... Mirage? <br />

    Anil Madhavapeddy, University of Cambridge
    <br />
    Functional Programming eXchange 2014, London
    <br />

    <div style="font-size: 24pt">
      __Homepage__: [http://openmirage.org](http://openmirage.org)
      <br />
      __Slides__: [http://decks.openmirage.org/fpx14/](http://decks.openmirage.org/fpx14/#/)
    </div>
    <br />
    <small>
      Work funded in part by the EU FP7 User-Centric Networking project, Grant
      No. 611001.
    </small>
    <img id="ucn-logo" src="/img/ucn-logo.png" />
    <br />
    <small>Press &lt;esc&gt; to view the slide index, and the &lt;arrow&gt; keys to navigate.</small>
 </script>
</section>

<section>
  <section data-markdown>
    <script type="text/template">
    ## Systems Programming Today

    > It’s considered good programming practice to focus
    > on compositionality: build software out of small, well-defined
    > modules that combine to give rise to other modules with different
    > behaviors.
    >
    > **This is simply too difficult to do in distributed systems. Why?**

    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
*-- Marius Eriksen, Principal Engineer, Twitter* *([source](http://monkey.org/~marius/sosp13.html))*

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## From simple servers...

    Traditional systems programming has involved building services in
    *one* environment.  e.g. Server, client, or embedded.

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
    ## ...To deep-sea diving

    Traditional systems programming has involved building services in
    *one* environment.  A modern programmer deals with diverse targets:

    - **Cloud services** with unpredictable traffic spikes and failures.
    - **Smartphone programming** on ARM/x86 with power budgets.
    - **JavaScript** user interfaces with asynchronous web clients.
    - **Internet of Things** devices that have little ARM M0 processors.
    - **Kernel modules** to extend operating system functionality.

    <br />
    Quite often, one problem straddles multiple targets, with little
    opportunity for code re-use.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Systems Programming Today

    This is particularly true in a modern operating system.  APIs such
    as POSIX are difficult to evolve for changing needs.

```
fds.fd = open("/dev/netmap", O_RDWR);
strcpy(nmr.nm_name, "ix0");
ioctl(fds.fd, NIOCREG, &nmr);
p = mmap(0, nmr.memsize, fds.fd);
nifp = NETMAP_IF(p, nmr.offset);
fds.events = POLLOUT;
for (;;) {
 poll(fds, 1, -1);
 for (r = 0; r < nmr.num_queues; r++) {
  ring = NETMAP_TXRING(nifp, r);
  while (ring->avail-- > 0) {
   i = ring->cur;
   buf = NETMAP_BUF(ring, ring->slot[i].buf_index);
   ... store the payload into buf ...
   ring->slot[i].len = ...
   ring->cur = NETMAP_NEXT(ring, i);
```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Possible Solution!

    Can we disentangle the application from the operating system?

    - Break up **OS logic into libraries**.  We chose **OCaml** for its powerful module system and simple runtime semantics.

    - Build **applications as functors** across OS functionality such as I/O.

    - Develop on Unix, but compile **specialized type-safe microkernels** for production use.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## A Possible Solution!

    These slides are written in a library operating system called [MirageOS](http://openmirage.org):

    - Hosted on a <b>~1MB Xen microkernel written in statically
    type-safe OCaml</b>, including the device drivers, TCP and HTTP stack.

    - The application logic was just a <b>couple of source files</b>, written
     as a portable functor independent of OS dependencies.

    - The kernel is <b>running on the public cloud</b> on Amazon EC2, with
    the binaries small enough to be tracked in Git.

    </script>
  </section>

</section>

<section>

  <section data-markdown>
    <script type="text/template">
      ## The Cloud Threat Model

      <img src="threat-model.png" />

      <div class="fragment">
        <img class="arrow"
             style="top: -320pt; left: 290pt; height: 6cm"
             src="green-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <img class="arrow"
             style="top: -190pt; left: 180pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="red-arrow.png" />

        <p class="bubble  right"
           style="top: -440pt; left: -5pt; width: 11em">
          Type-safety in the application layer defeats several external threats.
        </p>
     </div>

      <div class="fragment">
        <img class="arrow"
             style="top: -482pt; left: 307pt; height: 6cm;
                    -webkit-transform: rotate(-90deg)"
             src="green-arrow.png" />

        <p class="bubble "
           style="top: -730pt; left: 370pt; width: 12em">
          Type-safety in the kernel will make all external I/O safe, but at what
          cost?
        </p>
      </div>

    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Current Virtual Appliances

      <img src="vapps-current.png" />

      Compiler has to stop at userspace.

      Every level has a different API, calling convention, and privilege requirements.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-1.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-2.png" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Specialised Virtual Appliances

      <img src="vapps-specialised-3.png" />
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Target the hypervisor

      <img src="key-insight.png" />
      <p class="fragment bubble "
         style="top: -320pt; left: 190pt; width: 14.5em">
        UNIX processes get mapped onto many small, independent, virtual machines forming a distributed system.
      </p>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Key Design Insights

      <img src="key-insight.png" />

      <div class="fragment">
      <p class="bubble"
         style="top: -300pt; left: 220pt; width: 15em">
        The hypervisor gifts us a stable hardware interface. Cures the curse
        of research operating systems!
      </p>
      </div>
      <div class="fragment">
      <p class="bubble left"
         style="top: -260pt; left: 380pt; width: 9.5em">
        Protocol-level compatibility between special-purpose
        appliances is enough.
      </p>
      </div>
    </script>
  </section>

</section>

<section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code

      ```
module Main (C: CONSOLE) = struct

 let start c =
    ...
end
```

`C` is an abstract module that implements the `CONSOLE` signature.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code

      ```
module Main (C: CONSOLE) = struct

 let start c =
  C.log_s c "Hello Mirage World"
  >>= fun () ->
  let rec aux () =
   C.log_s c "."
   >>= fun () ->
   OS.Time.sleep 1.
   >>= aux
  in
  aux ()

end
```
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code
      - Write a configuration file for the compilation

      ```
let () =
  let unikernel = console @-> job in
  ...
      ```

The `@->` combinator builds up a list of device driver types.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code
      - Write a configuration file for the compilation

      ```
let () =
  let unikernel = console @-> job in
  let job1 = foreign "Handler.Main" unikernel $ default_console in
  register "console" [ job1 ]
      ```

`job1` is a concrete job that defines an entry point and applies the `default_console` to the Hello World program earlier.

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code
      - Write a configuration file for the compilation
      - Compile it under UNIX using the OPAM package manager

      ```
$ opam install mirage
$ mirage configure --unix
$ make
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code
      - Write a configuration file for the compilation
      - Compile it under UNIX using the OPAM package manager
      - Once debugged, just recompile the same source code to Xen!

      ```
$ mirage configure --xen
$ make
$ xl create -c mirage-www.conf
      ```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## MirageOS Workflow

      - Write a normal bit of OCaml source code
      - Write a configuration file for the compilation
      - Compile it under UNIX using the OPAM package manager
      - Once debugged, just recompile the same source code to Xen!
      - The magic happens via the OCaml module system

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules1.png" />

    </script>
  </section>


   <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules2.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Modularizing the OS

      <img src="modules3.png" />

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Jack of all deployments

       This gets very cool with more complex applications like the live website: <https://github.com/mirage/mirage-www/blob/master/src/config.ml>

```
let main =
 let libraries = [ "cow.syntax"; "cowabloga" ] in
 let packages = [ "cow";"cowabloga" ] in
 foreign ~libraries ~packages "Dispatch.Main"
  (console @-> kv_ro @-> kv_ro @-> http @-> job)
```
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Jack of all deployments

       This gets very cool with more complex applications like the live website: <https://github.com/mirage/mirage-www/blob/master/src/config.ml>

```
let main =
 let libraries = [ "cow.syntax"; "cowabloga" ] in
 let packages = [ "cow";"cowabloga" ] in
 foreign ~libraries ~packages "Dispatch.Main"
  (console @-> kv_ro @-> kv_ro @-> http @-> job)
```

   Website can be recompiled as:

- Xen unikernel with all data built into image.
- Xen unikernel with data dynamically read from disk.
- Unix binary with data passed through to filesystem.
- Unix binary with OCaml userlevel TCP/IP stack.
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Building these modules

      OPAM includes a SAT-solver to pick modules for a given hardware target *(can include Xen vs Linux dom0+Xen vs kFreeBSD)*

      Libraries are lightweight and independent (on GitHub), e.g.,

      - **[mirage/ocaml-xenstore](https://github.com/mirage/ocaml-xenstore)** - abstract, Unix/Xen interface.
      - **[mirage/shared-memory-ring](https://github.com/mirage/shared-memory-ring)** - shared memory protocol for Xen drivers.
      - **[mirage/ocaml-xen-block-driver](https://github.com/mirage/ocaml-xen-block-driver)** - Unix/Xen Blkfront/Blkback.
      - **[mirage/ocaml-vchan](https://github.com/mirage/ocaml-vchan)** - Unix/Xen Vchan shared memory transport.
      - **[mirage/mirage-platform](https://github.com/mirage/mirage-platform)** - UNIX/Xen/NS3 versions of timer, shared memory and event channels.

    </script>
  </section>

</section>



<section>
  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## What is an Operating System?

    > "An operating system is a collection of software that manages computer
    > hardware resources and provides common services for computer programs."

    <br />
    While this traditionally means a monolithic OS such as Linux or Windows,
    it can also describe a **library operating system**.

    - Every OS service exposed as a library with few ambient services.
    - Application links directly with the drivers to boot (a *"unikernel"*)
    - A natural fit to the ML module system.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

```
let rec qsort = function
 | [] -> []
 | pivot :: rest ->
  let is_less x = x < pivot in
  let left, right = List.partition is_less rest in
  qsort left @ [pivot] @ qsort right
```
    **Why?**
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

```
let rec qsort = function
 | [] -> []
 | pivot :: rest ->
  let is_less x = x < pivot in
  let left, right = List.partition is_less rest in
  qsort left @ [pivot] @ qsort right
```

    **Why?** It runs sequentially, meaning that it only needs:

    - to run as native code
    - a garbage collector
    - a console log to record output
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

```
let rec qsort = function
 | [] -> []
 | pivot :: rest ->
  let is_less x = x < pivot in
  let left, right = List.partition is_less rest in
  qsort left @ [pivot] @ qsort right
```

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

   <section data-markdown>
        <script type="text/template">
          ## Kernel Memory Management

          <img src="memory-model.png" />


          <p class="fragment bubble"
             style="top: -410pt; left: 195pt; width: 20em; font-size: 20pt">
            Compiled native source code and runtime statically linked and boots
            directly into Xen.
          </p>

          <p class="fragment bubble  right"
             style="top: -390pt; left:-66pt; width: 12em; font-size: 20pt">
            IO memory is mapped into a reserved area and can be distinguished.
          </p>

          <p class="fragment bubble  left"
             style="top: -280pt; left: 320pt; width: 12em; font-size: 20pt">
            OCaml heap is contiguous, with simpler write barriers as a result.
          </p>

        </script>
      </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

```
let rec qsort = function
 | [] -> []
 | pivot :: rest ->
  let is_less x = x < pivot in
  let left, right = List.partition is_less rest in
  qsort left @ [pivot] @ qsort right
```

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - no concurrency
    - no significant network or disk I/O
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## A Minimal Kernel

    A simple OCaml program like this is easy to run without Unix.

```
let rec qsort = function
 | [] -> []
 | pivot :: rest ->
  let is_less x = x < pivot in
  let left, right = List.partition is_less rest in
  qsort left @ [pivot] @ qsort right
```

    **Why?** It runs sequentially, meaning that it only needs:

    - <s>to run as native code</s> &nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; **`ocamlopt -output-obj`**
    - <s>a garbage collector</s> &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;**link OCaml runtime to Xen MiniOS**
    - <s>a console log to record output</s> &nbsp; **log to virtual machine console**
    - **implement language-level concurrency via monads**
    - **build device drivers via modular blocks**
    </script>
  </section>
</section>


<section>
  <section data-markdown>
    <script type="text/template">
    ## Monads

```
module type MONAD = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

* A monad is a box that contains an abstract value.
* Put values in the box with `return`
* Transform them into other values with `bind`

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## The Option Monad

    Let's implement a monad that expresses optional values, starting in the OCaml interactive toplevel.

```
# Some "apple" ;;
- : string option = Some "apple"

# None ;;
- : 'a option = None

# let return x = Some x ;;
val return : 'a -> 'a option = <fun>

# let maybe u f =
 match u with
 | Some c -> f c
 | None   -> None ;;
val maybe : 'a option -> ('a -> 'b option) -> 'b option = <fun>
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

```
module OptionMonad =
 struct
  type α t = α option

  let bind u f =
   match f with
   | Some x -> f x
   | None   -> None

  let return u = Some u
end
```

The toplevel will report the following type:

```
module OptionMonad = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```
    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: definition

```
module OptionMonad =
 struct
  type α t = α option

  let bind u f =
   match f with
   | Some x -> f x
   | None   -> None

  let return u = Some u
end
```

    - The value in the box may or may not exist, so is `type α option`
    - `return` places a concrete value in the box.
    - `bind` applies a function to it if it exists, and does nothing otherwise.

    - Notice that the `f x` application in `bind` is *not* wrapped in a `Some`.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: examples

    Some simple uses of these definitions:

```
open OptionMonad ;;
bind (return 1) (fun c -> return (c+1)) ;;
- : int option = Some 2

bind None (fun c -> return (c+1)) ;;
- : int option = None
```

    Binds can be chained to link the results.

```
bind (
 bind
  (Some 1)
  (fun c -> return (c+1))
 ) (fun c -> return (c+1)) ;;
- : int option = Some 3
```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

```
let (>>=) = bind ;;
val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

return 1 >>= fun c ->
return (c+1) >>= fun c ->
return (c+1) ;;
- : int option = Some 3
```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Option Monad: infix operators

    Infix operators make chaining `bind` more natural:

```
let (>>=) = bind ;;
val ( >>= ) : 'a option -> ('a -> 'b option) -> 'b option = <fun>

return 1 >>= fun c ->
return (c+1) >>= fun c ->
return (c+1) ;;
- : int option = Some 3
```

    Or define a `maybe_add` function to be even more succinct.

```
let maybe_add c = return c + 1 ;;
val maybe_add : int -> int option = <fun>

return 1
>>= maybe_add
>>= maybe_add
- : int option = Some 3
```
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Monad Laws

```
module type MONAD = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

* Monad implementations must satisfy some laws.

    </script>

  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: left identity

```
module type MONAD = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

`return` is a left identity for `bind`

```
return x >>= f
f x
```

Using the OptionMonad:

```
# return 1 >>= maybe_add ;;
- : int option = Some 2

# maybe_add 1;;
- : int option = Some 2

# return (Some 1) >>= maybe_add
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: right identity

```
module type MONAD = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

`return` is a right identity for `bind`

```
m >>= return
m
```

    Using the OptionMonad:

```
# Some 1 >>= return
- : int option = Some 1

# None >>= return
- : 'a option = None
```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Monad Laws: associativity

```
module type MONAD = sig
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

`bind` is associative (in an odd way).


```
(u >>= f) >>= g
u >>= (fun x -> f x) >>= g
```

Using the OptionMonad:

```
# Some 3 >>= maybe_add >>= maybe_add ;;
- : int option = Some 5

# Some 3 >>= (fun x -> maybe_add x >>= maybe_add) ;;
- : int option = Some 5
```

    </script>
  </section>
</section>

<section>

  <section data-markdown>
    <script type="text/template">
    ## Cooperative Concurrency

    There are quite a few uses for monads; we'll use this to build a cooperative concurrency model for our OS.

```
module Lwt = struct
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t
end
```

    The `Lwt` (Light Weight Thread) monad signature above represents a *future computation* that is held in the box.

    Can construct *futures* and compute using them by using `bind` to operate over its eventual value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Constant threads

```
open Lwt ;;
let future_int = return 1 ;;
val future_int : int Lwt.t = <abstr>
```

    Build a constant thread by using `return`.

```
let future_fruit = return "apple" ;;
val future_fruit : string Lwt.t = <abstr>

let future_lang = return `OCaml ;;
val future_lang : [> `OCaml] Lwt.t = <abstr>
```

    Threads are first-class OCaml values and parametric polymorphism lets you
    distinguish different types of threads.

    No system threads are involved at all; this is sequential code.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

```
module OS = struct
 val sleep : float -> unit Lwt.t
 val run : 'a Lwt.t -> 'a
end
```

    The monad needs to be *executed* to retrieve the future contents.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

```
module OS = struct
 val sleep : float -> unit Lwt.t
 val run : 'a Lwt.t -> 'a
end
```

    The monad needs to be *executed* to retrieve the future contents.

```
let t =
 OS.sleep 1.0 >>= fun () ->
 print_endline ">> start";
 OS.sleep 2.0 >>= fun () ->
 print_endline ">> woken up";
 return () ;;
val t : unit Lwt.t = <abstr>
```

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Concurrency: executing

```
module OS = struct
 val sleep : float -> unit Lwt.t
 val run : 'a Lwt.t -> 'a
end
```

    The monad needs to be *executed* to retrieve the future contents.

```
let t =
 OS.sleep 1.0 >>= fun () ->
 print_endline ">> start";
 OS.sleep 2.0 >>= fun () ->
 print_endline ">> woken up";
 return () ;;
val t : unit Lwt.t = <abstr>

OS.run t ;;
>> start
>> woken up
```

    The `run` function takes a future and unpacks the real value.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Joinad: not quite a monad

```
module Lwt = struct
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t

 val join : unit t list -> unit t
 val choose : α t list -> α t
end
```

    We extend the `MONAD` signature with:

    - `join` to wait for a list of threads to terminate.
    - `choose` to return as soon as one thread of a list completes.
    - `join` is also defined as the `<&>` operator, and `choose` as `<?>`.

    <br/>
    *(see [tomasp.net](http://tomasp.net) and [tryjoinads.org](http://tryjoinads.org) for more background)*

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Example: flip a coin

```
module Lwt = struct
 type α t
 val bind : α t -> (α -> β t) -> β t
 val return :  α -> α t

 val join : unit t list -> unit t
 val choose : α t list -> α t
end
```

    Using `choose` to pick the first thread in a coin flip:

```
let flip_a_coin () =
 let heads =
  OS.sleep 1.0 >>= fun () ->
  return (OS.log "Heads") in
 let tails =
  OS.sleep 2.0 >>= fun () ->
  return (OS.log "Tails") in
 heads <&> tails
```

    </script>
  </section>



  <section data-markdown>
    <script type="text/template">
    ## Representation of a thread

```
type 'a t = {
 | Return of 'a
 | Fail of exn
 | Sleep of 'a sleeper
}
and sleeper = {
 waiters : 'a waiter_set;
 <...etc>
}
```

    Thread has three main states:

    - It has **completed** and contains a concrete `Return` value.
    - It has **failed** and contains a concrete `Fail` exception.
    - It is **blocked** and waiting on another thread.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

```
type 'a t  (* thread *)
type 'a u  (* wakener *)
val wait : unit -> 'a t * 'a u
val wakeup : 'a u -> 'a -> unit
```

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
    ## Wakeners and tasks

    Each thread executes until it needs to wait on a resource.  It creates
    a *task* to let it be woken up in the future.

```
type 'a t  (* thread *)
type 'a u  (* wakener *)
val wait : unit -> 'a t * 'a u
val wakeup : 'a u -> 'a -> unit
```

    Tasks are a pair: a thread that sleeps until it is fulfilled via its wakener by calling `wakeup` on it.

```
let t1 =
 t >>= fun x ->
 print_endline x;
 return ()
and t2 =
 OS.sleep 2.0 >>= fun () ->
 wakeup u "x";
 return ()
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: building a timer

    Wakeners are enough to build our `OS.sleep` function:

    - Call `sleep` with `t` seconds as an argument.
    - Create a thread `t` and a wakener `u`.
    - Insert `u` into a priority queue of timeouts, ordered by duration.
    - The application sleeps on `t` until `u` is invoked by the scheduler.

    <br />
    The priority queue is a standard data structure ordered by duration.

```
module Sleep_queue =
 Lwt_pqueue.Make(struct
  type t = sleeper
  let compare { time = t1 } { time = t2 } = compare t1 t2
 end)
end
```

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Unix

    The `OS.main` function runs until all threads are blocked,
    and then drops into the `select` function to wait for the next timeout.

```
run main thread (threads register timeouts)
if result is Blocked then
 T = head of priority queue
 select() for T seconds
 wakeup timeouts
repeat until main thread result is Done or Fail
```

     - This lets our sequential code be fully concurrent, without preemptive system threads.
     - Number of threads limited only by OCaml heap size.

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    **But how does this translate to Xen?**

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

```
module OS = struct
 val sleep : float -> unit Lwt.t
 val run : 'a Lwt.t -> 'a
end
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
    ## Wakeners: running in Xen

    Lwt uses the `select` system call in Unix, which blocks the process until some IO event (or a timeout) occurs.

    Xen has an equivalent *VM block instruction* which suspends the whole VM until a device interrupt or timeout.

    > **processes in Unix** <=> **Virtual Machines in Xen**

    > **`select` in Unix** <=> **block entire virtual machine in Xen**

    Our Xen VM can use this abstraction for all its I/O and timing.

    **Question: What is the major downside of this approach?**
    </script>
  </section>


</section>

<section>
  <section data-markdown>
    <script type="text/template">
      ## Microbenchmarks!

      Unikernel appliances are:

      + Smaller, both in kLoC & image size
      + Boot faster, _at packet round-trip time timescales_
      + High performance
      + Type-safe

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Appliance Image Size

      <table style="border-bottom: 1px black solid">
        <thead style="font-weight: bold">
          <td style="border-bottom: 1px black solid; width: 15em">Appliance</td>
          <td style="border-bottom: 1px black solid">Standard Build</td>
          <td style="border-bottom: 1px black solid">Dead Code Elimination</td>
        </thead>
        <tbody>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>DNS</td><td>0.449 MB</td><td>0.184 MB</td>
          </tr>
          <tr>
            <td>Web Server</td><td>0.674 MB</td><td>0.172 MB</td>
          </tr>
          <tr style="background-color: rgba(0, 0, 1, 0.2)">
            <td>Openflow learning switch</td><td>0.393 MB</td><td>0.164 MB</td>
          </tr>
          <tr>
            <td>Openflow controller</td><td>0.392 MB</td><td>0.168 MB</td>
          </tr>
        </tbody>
      </table>

      <br />
      All configuration and data compiled into the image by the toolchain.

      Live migration is easy and fun :-)
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Boot Time

      <img src="boot-time.png" />

      _Unikernels are compact enough to boot and respond to network traffic in
      real-time._
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## How Large is Large?

      <img src="kloc.png">
      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Event Driven Co-Threads

        <img style="padding-top:1ex" src="cothreads.png" />

        _Garbage collected heap management is more efficient in a single
        address-space environment. Thread latency can be reduced by eliminating
        multiple levels of scheduling._

      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Thread Scaling <small>single instance</small>

        <img src="thread-scaling.png" />

        _Threads are heap allocated values, so benefit from the faster garbage
        collection cycle in the Mirage Xen version, and the scheduler can be
        overridden by application-specific needs._

      </script>
    </section>

    <section data-markdown>
      <script type="text/template">
        ## Block Storage

        <img style="max-width: 78%;" src="block-storage.png" />

        _Additionally, reading __from__ a Mirage NAS-like storage VM achieves
        942MiB/s buffered, and 1.8GiB/s unbuffered._

        </script>
      </section>

    </section>

      <section>
        <section data-markdown>
          <script type="text/template">
            ## Macrobenchmarks

            We have implemented several larger appliances.

            We discuss _deens_, our DNS server in detail here.

            We also have:

            + a simple webserver,
            + an OpenFlow Switch, and
            + an OpenFlow Controller.

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>baseline</small>

            <img style="max-width: 85%" src="dns-baseline.png" />

            _Baseline figures, running __Bind__ (standard) and __NSD__ (high
            performance). NSD achieves around 70 kreqs/s._

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>mirage</small>

            <img style="max-width: 85%" src="dns-deens.png" />

            _Comparing against __Mirage__ appliance, with and without simple
            memoisation. This __algorithmic__ optimisation added just 6 lines of code._
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## DNS Server Performance <small>C/miniOS</small>

            <img style="max-width: 85%" src="dns-all.png" />

            _A rudimentary C-based appliance linking NSD directly against
            MiniOS. Poor user-space library performance
            vastly outweighs language effects._
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## Scaling <small>via Parallel Instances</small>

            <img  src="scaling-instances.png" />

            _Request throughput for serving a simple static page using  Apache on Linux
            vs. a Mirage appliance. Rather than pay the cost of interlocking for
            thread-level parallelism, we scale by running many instances of the
            Mirage appliance._

          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            ## Openflow Controller

            <img src="openflow-controller.png">

              _OpenFlow controller is competitive with NOX (C++), but much higher
              level. Applications can link directly against the switch to route their
              data._

            </script>
          </section>
        </section>
<section>
  <section data-markdown>
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

<br />

    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1a.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1b.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1c.png" height="700" />
    </script>
  </section>
  <section data-markdown>
    <script type="text/template">
      ## Compiler in the Middle

      <img src="uniarch1d.png" height="710" />
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Orchestration

      Deploying unikernels on the cloud is much like starting binaries in Unix.
<http://amirchaudhry.com/from-jekyll-to-unikernel-in-fifty-lines/>

      + Contain a *precise* manifest of source code dependencies.
      + Type-checking compiler sits between the source code and the cloud.

<br />

      + Unikernels are small and can be tracked in GitHub!
        + For Mirage website, source is committed to **[mirage/mirage-www](https://github.com/mirage/mirage-www)**
        + Pull requests to source are built by **[Travis-CI](https://travis-ci.org)**
        + Resulting binary committed to **[mirage/mirage-www-deployment](https://github.com/mirage/mirage-www-deployment)**
        + Cloud toolstack spawns VMs based on pushes there.


    </script>
  </section>
</section>


  <section>
   <section data-markdown>
     <script type="text/template">
      ## Experiences

      + __OCaml is the baseline language for all new code__
        + Our C runtime is small, and getting smaller.
        + Is fully event-driven and non-preemptive.
        + Safe modularity at scale is incredible.
      + __Rewriting protocols wasn&rsquo;t that hard__
        + An extremely useful learning experience.
        + Clean slate often highlights research opportunities.
        + Pickup by industry has been vital.
      + __Unikernels fit perfectly on the cloud__
        + Internet protocol building blocks.
        + Seamless interop with legacy code through VMs.
      </script>
    </section>
    <section data-markdown>
    <script type="text/template">
      ## MirageOS 1.1 - February 2014

      - It's not just the source code: __tools matter__ too.
          - Release efforts are focussed around usability of build/deployment.
          - OPAM 1.1 package manager that works via GitHub: **<https://opam.ocaml.org>**
          - over 50 OCaml libraries released (TCP/IP, Xen drivers, protocols)

      <br />

      - OPAM now has **over 2000 packages** (620+ unique)
          - lots of enthusiasm from the OCaml community!
          - growing corpus of re-usable code
          - a single place to discover functionality
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## OPAM Package Growth

      <img src="packages.png" />
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
      ## To the Edge of the Cloud

      The library OS approach is far more general than just cloud programming.

      - **ARMv6/Raspberry Pi** - needs device drivers for framebuffer/USB
      - **kernel/FreeBSD** - OS environment is a kernel module
      - **JavaScript/browser** - map WebSockets/HTML5 Storage
      - **ARMv8/Xen** - emerging support for new ARM hypervisors
      - **VMWare/KVM/LXC** - more hypervisor boot libraries
      - **Unix/Capsicum/CHERI** - secure capability hardware

    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## Use Cases that Drive Us

      - __Personal Hosting__ ([User Centric Networking](http://usercentricnetworking.eu))
        - Our homepages moving onto little self-contained kernels.
        - Self-scaling servers that spawn VMs in response to demand.
        - ARM Raspberry Pi protocol servers.
        - Security less of a problem due to dependency tracking.

      <br />

      - __Network as a Service__
        - Data centre applications customize their network needs.
        - Operations over big data can specialize to workloads.
        - Exploring the hardware/software divide.


    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
      ## But lots of polishing to do!

      - __Low latency toolstacks__
        - Nothing stops Xen being as easy as containers.
        - Focus has been on large VMs, but being optimized.
        - Streaming kernels via HTTP-RPC now works.
      - __Configuration Language__
        - Very raw in 1.0, but usecases will drive it.
        - All the policy has been pushed out here.
      - __More seamless interoperability__
        - Combine with other languages (**[ocamllabs/ocaml-ctypes](https://github.com/ocamllabs/ocaml-ctypes)**)
        - More boot libraries (KVM, VirtualBox, Docker, rPi, Xen/ARM).
        - Scheduling in such extremely distributed systems.

    </script>
  </section>

  <section data-markdown>
      <script type="text/template">
      <img width="220" src="rwo.jpg" style="margin-left: 680px; margin-top: 150px; position: fixed" />
      ## MirageOS Online

      + Website, <http://www.openmirage.org>
      + Code, <http://github.com/mirage>
      + O'Reilly OCaml book, <http://realworldocaml.org>
      + **Google Summer of Code** and <br />**Outreach Program for Women** open!

      + All development open and on GitHub:
         + **<https://github.com/mirage>**
         + **<https://github.com/xapi-project>**
         + **<https://github.com/xenserver>**

      On behalf of Thomas Gazagnaire, David Scott, Richard Mortier.
      </script>
   </section>

</section>
